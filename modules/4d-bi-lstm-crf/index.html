<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/libs/katex/katex.min.css">

  <link rel="stylesheet" href="/libs/highlight/styles/github.min.css">

  <link rel="stylesheet" href="/css/franklin.css">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,400italic|Source+Code+Pro:400,700"
    type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/celeste.min.css">

  <link rel="icon" type="image/png" sizes="200x200" href="/assets/robot.png">
  <!-- <link rel="shortcut icon" href="/assets/favicon.ico"> -->
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="/assets/apple-touch-icon.png">


  <title>NLPwShiyi - Natural Language Processing with Shiyi</title>
</head>

<body>
  <!-- Latest compiled and minified CSS -->

  <nav id="navbar" class="navigation" role="navigation">
    <input id="toggle1" type="checkbox" />
    <label class="hamburger1" for="toggle1">
      <div class="top"></div>
      <div class="meat"></div>
      <div class="bottom"></div>
    </label>

    <nav class="topnav mx-auto" id="myTopnav">
      <div class="dropdown">
        <button class="dropbtn">Comp Ling
          <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
          <a href="/modules/1a-info-theory">Information Theory</a>
          <a href="/modules/1b-phil-of-mind">Philosophy of Mind</a>
          <a href="/modules/1c-noisy-channel-model">The Noisy Channel Model</a>
          <a href="/modules/1d-finite-automata">FSAs and FSTs</a>
          <a href="/modules/1e-mutual-info">Mutual Information</a>
          <a href="/modules/1f-cky-algorithm">CKY Algorithm</a>
          <a href="/modules/1g-viterbi">Viterbi Algorithm</a>
          <a href="/modules/1h-semantics">Logic and Problem Solving</a>
          <a href="/modules/1i-cryptanalysis">Cryptography</a>
        </div>
      </div>
      <div class="dropdown">
        <button class="dropbtn">DL / NLP
          <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
          <a href="/modules/2a-mdn-nlp">Modern NLP</a>
          <a href="/modules/2b-markov-processes">Markov Processes</a>
          <a href="/modules/2c-word2vec">Word2Vec</a>
          <a href="/modules/2d-automatic-differentiation">Automatic Differentiation</a>
          <a href="/modules/2e-jax">Jacobian Matrices Derivation</a>
          <a href="/modules/2f-loss-functions">Stochastic GD</a>
          <a href="/modules/2g-batchnorm">Batchnorm</a>
          <a href="/modules/2h-dropout">Dropout</a>
          <a href="/modules/2i-depth">Depth: Pros and Cons</a>
        </div>
      </div>
      <a href="/" class="active">Intro </a>
      <div class="dropdown">
        <button class="dropbtn">SOTA
          <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
          <a href="/modules/3a-VAE">Variational Autoencoders</a>
          <a href="/modules/3b-dnns">DNNs(RNNs, CNNs, (Bi)-LSTM)</a>
          <a href="/modules/3c-transformers">Transformers</a>
          <!-- <a href="/modules/">TODO: Diffusion Prob Models</a> -->
        </div>
      </div>
      <div class="dropdown">
        <button class="dropbtn">Hands-on
          <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
          <a href="/modules/4a-mlp-from-scratch">MLP from Scratch</a>
          <a href="/modules/4b-generative-adversarial-networks">GAN Example </a>
          <a href="/modules/4c-vae-mnist">VAE for MNIST</a>
          <a href="/modules/4d-bi-lstm-crf">BI-LSTM-CRF S2S</a>
          <a href="/modules/4e-c4fe-tbip">C4FE-TBIP</a>
          <a href="/modules/4f-etl-job">DE: Serverless ETL</a>

        </div>
      </div>
    </nav>
  </nav>

  <!-- Content appended here -->
  <div class="franklin-content">
    <h2 id="making_dynamic_decisions_with_sequence_to_sequence_language_processing_tasks"><a
        href="#making_dynamic_decisions_with_sequence_to_sequence_language_processing_tasks"
        class="header-anchor">Making Dynamic Decisions with Sequence to Sequence Language Processing Tasks</a></h2>
    <div class="franklin-toc">
      <ol>
        <li><a href="#making_dynamic_decisions_with_sequence_to_sequence_language_processing_tasks">Making Dynamic
            Decisions with Sequence to Sequence Language Processing Tasks</a></li>
      </ol>
    </div>
    <p>For this section, we will see a full, complicated example of a Bi-LSTM Conditional Random Field for named-entity
      recognition. </p>
    <p>The LSTM tagger above is typically sufficient for part-of-speech tagging, but a sequence model like the CRF is
      really essential for strong performance on NER. </p>
    <p>Familiarity with CRF’s is assumed. Although this name sounds scary, all the model is a CRF but where an LSTM
      provides the features. </p>
    <p>This is an advanced model though, far more complicated than any earlier model in this tutorial. If you want to
      skip it, that is fine. To see if you’re ready, see if you can:</p>
    <p>Write the recurrence for the viterbi variable at step i for tag k.</p>
    <p>Modify the above recurrence to compute the forward variables instead.</p>
    <p>Modify again the above recurrence to compute the forward variables in log-space &#40;hint: log-sum-exp&#41;</p>
    <p>If you can do those three things, you should be able to understand the code below. Recall that the CRF computes a
      conditional probability. Let \(y\) be a tag sequence and \(x\) an input sequence of words. Then we compute</p>
    <p>The image contains mathematical equations and explanations related to a Conditional Random Field &#40;CRF&#41;
      model used in conjunction with a Bi-LSTM neural network for sequence tagging tasks. Here are the equations
      presented in LaTeX:</p>
    <ol>
      <li>
        <p>The conditional probability of a tag sequence \(y\) given an input sequence \(x\) is computed as:</p>
      </li>
    </ol>
    \[ P(y|x) = \frac{\exp(\text{Score}(x, y))}{\sum_{y'} \exp(\text{Score}(x, y'))} \]
    <ol start="2">
      <li>
        <p>The score of a sequence is the sum of log potentials \(\psi_i(x, y)\):</p>
      </li>
    </ol>
    \[ \text{Score}(x, y) = \sum_{i} \log \psi_i(x, y) \]
    <ol start="3">
      <li>
        <p>The score is further detailed for a Bi-LSTM CRF model, considering emission and transition potentials:</p>
      </li>
    </ol>
    \[ \text{Score}(x, y) = \sum_{i} \log \psi_{\text{EMIT}}(y_i \rightarrow x_i) + \log \psi_{\text{TRANS}}(y_{i-1}
    \rightarrow y_i) \]
    <ol start="4">
      <li>
        <p>The score is then expressed in terms of the hidden state \(h_i\) of the Bi-LSTM and the transition scores
          \(P_{y_i,y_{i-1}}\):</p>
      </li>
    </ol>
    \[= \sum_{i} h_i[y_i] + P_{y_i,y_{i-1}}\]
    <p>The text also mentions that the potentials must only look at local features to make the partition function
      tractable and that the transition scores are stored in a matrix \(P\), where \(P_{j,k}\) is the score of
      transitioning to tag \(j\) from tag \(k\).</p>
    <p>The example below implements the forward algorithm in log space to compute the partition function, and the
      viterbi algorithm to decode. Backpropagation will compute the gradients automatically for us. We don’t have to do
      anything by hand.</p>
    <p>The implementation is not optimized. If you understand what is going on, you’ll probably quickly see that
      iterating over the next tag in the forward algorithm could probably be done in one big operation. I wanted to code
      to be more readable. If you want to make the relevant change, you could probably use this tagger for real tasks.
    </p>
    <pre><code class="language-python">import torch
import torch.autograd as autograd
import torch.nn as nn
import torch.optim as optim

torch.manual_seed&#40;1&#41;</code></pre>
    <pre><code class="language-python">def argmax&#40;vec&#41;:
    # return the argmax as a python int
    _, idx &#61; torch.max&#40;vec, 1&#41;
    return idx.item&#40;&#41;


def prepare_sequence&#40;seq, to_ix&#41;:
    idxs &#61; &#91;to_ix&#91;w&#93; for w in seq&#93;
    return torch.tensor&#40;idxs, dtype&#61;torch.long&#41;


# Compute log sum exp in a numerically stable way for the forward algorithm
def log_sum_exp&#40;vec&#41;:
    max_score &#61; vec&#91;0, argmax&#40;vec&#41;&#93;
    max_score_broadcast &#61; max_score.view&#40;1, -1&#41;.expand&#40;1, vec.size&#40;&#41;&#91;1&#93;&#41;
    return max_score &#43; \
        torch.log&#40;torch.sum&#40;torch.exp&#40;vec - max_score_broadcast&#41;&#41;&#41;</code></pre>
    <p>create model </p>
    <pre><code class="language-python">class BiLSTM_CRF&#40;nn.Module&#41;:

    def __init__&#40;self, vocab_size, tag_to_ix, embedding_dim, hidden_dim&#41;:
        super&#40;BiLSTM_CRF, self&#41;.__init__&#40;&#41;
        self.embedding_dim &#61; embedding_dim
        self.hidden_dim &#61; hidden_dim
        self.vocab_size &#61; vocab_size
        self.tag_to_ix &#61; tag_to_ix
        self.tagset_size &#61; len&#40;tag_to_ix&#41;

        self.word_embeds &#61; nn.Embedding&#40;vocab_size, embedding_dim&#41;
        self.lstm &#61; nn.LSTM&#40;embedding_dim, hidden_dim // 2,
                            num_layers&#61;1, bidirectional&#61;True&#41;

        # Maps the output of the LSTM into tag space.
        self.hidden2tag &#61; nn.Linear&#40;hidden_dim, self.tagset_size&#41;

        # Matrix of transition parameters.  Entry i,j is the score of
        # transitioning *to* i *from* j.
        self.transitions &#61; nn.Parameter&#40;
            torch.randn&#40;self.tagset_size, self.tagset_size&#41;&#41;

        # These two statements enforce the constraint that we never transfer
        # to the start tag and we never transfer from the stop tag
        self.transitions.data&#91;tag_to_ix&#91;START_TAG&#93;, :&#93; &#61; -10000
        self.transitions.data&#91;:, tag_to_ix&#91;STOP_TAG&#93;&#93; &#61; -10000

        self.hidden &#61; self.init_hidden&#40;&#41;

    def init_hidden&#40;self&#41;:
        return &#40;torch.randn&#40;2, 1, self.hidden_dim // 2&#41;,
                torch.randn&#40;2, 1, self.hidden_dim // 2&#41;&#41;

    def _forward_alg&#40;self, feats&#41;:
        # Do the forward algorithm to compute the partition function
        init_alphas &#61; torch.full&#40;&#40;1, self.tagset_size&#41;, -10000.&#41;
        # START_TAG has all of the score.
        init_alphas&#91;0&#93;&#91;self.tag_to_ix&#91;START_TAG&#93;&#93; &#61; 0.

        # Wrap in a variable so that we will get automatic backprop
        forward_var &#61; init_alphas

        # Iterate through the sentence
        for feat in feats:
            alphas_t &#61; &#91;&#93;  # The forward tensors at this timestep
            for next_tag in range&#40;self.tagset_size&#41;:
                # broadcast the emission score: it is the same regardless of
                # the previous tag
                emit_score &#61; feat&#91;next_tag&#93;.view&#40;
                    1, -1&#41;.expand&#40;1, self.tagset_size&#41;
                # the ith entry of trans_score is the score of transitioning to
                # next_tag from i
                trans_score &#61; self.transitions&#91;next_tag&#93;.view&#40;1, -1&#41;
                # The ith entry of next_tag_var is the value for the
                # edge &#40;i -&gt; next_tag&#41; before we do log-sum-exp
                next_tag_var &#61; forward_var &#43; trans_score &#43; emit_score
                # The forward variable for this tag is log-sum-exp of all the
                # scores.
                alphas_t.append&#40;log_sum_exp&#40;next_tag_var&#41;.view&#40;1&#41;&#41;
            forward_var &#61; torch.cat&#40;alphas_t&#41;.view&#40;1, -1&#41;
        terminal_var &#61; forward_var &#43; self.transitions&#91;self.tag_to_ix&#91;STOP_TAG&#93;&#93;
        alpha &#61; log_sum_exp&#40;terminal_var&#41;
        return alpha

    def _get_lstm_features&#40;self, sentence&#41;:
        self.hidden &#61; self.init_hidden&#40;&#41;
        embeds &#61; self.word_embeds&#40;sentence&#41;.view&#40;len&#40;sentence&#41;, 1, -1&#41;
        lstm_out, self.hidden &#61; self.lstm&#40;embeds, self.hidden&#41;
        lstm_out &#61; lstm_out.view&#40;len&#40;sentence&#41;, self.hidden_dim&#41;
        lstm_feats &#61; self.hidden2tag&#40;lstm_out&#41;
        return lstm_feats

    def _score_sentence&#40;self, feats, tags&#41;:
        # Gives the score of a provided tag sequence
        score &#61; torch.zeros&#40;1&#41;
        tags &#61; torch.cat&#40;&#91;torch.tensor&#40;&#91;self.tag_to_ix&#91;START_TAG&#93;&#93;, dtype&#61;torch.long&#41;, tags&#93;&#41;
        for i, feat in enumerate&#40;feats&#41;:
            score &#61; score &#43; \
                self.transitions&#91;tags&#91;i &#43; 1&#93;, tags&#91;i&#93;&#93; &#43; feat&#91;tags&#91;i &#43; 1&#93;&#93;
        score &#61; score &#43; self.transitions&#91;self.tag_to_ix&#91;STOP_TAG&#93;, tags&#91;-1&#93;&#93;
        return score

    def _viterbi_decode&#40;self, feats&#41;:
        backpointers &#61; &#91;&#93;

        # Initialize the viterbi variables in log space
        init_vvars &#61; torch.full&#40;&#40;1, self.tagset_size&#41;, -10000.&#41;
        init_vvars&#91;0&#93;&#91;self.tag_to_ix&#91;START_TAG&#93;&#93; &#61; 0

        # forward_var at step i holds the viterbi variables for step i-1
        forward_var &#61; init_vvars
        for feat in feats:
            bptrs_t &#61; &#91;&#93;  # holds the backpointers for this step
            viterbivars_t &#61; &#91;&#93;  # holds the viterbi variables for this step

            for next_tag in range&#40;self.tagset_size&#41;:
                # next_tag_var&#91;i&#93; holds the viterbi variable for tag i at the
                # previous step, plus the score of transitioning
                # from tag i to next_tag.
                # We don&#39;t include the emission scores here because the max
                # does not depend on them &#40;we add them in below&#41;
                next_tag_var &#61; forward_var &#43; self.transitions&#91;next_tag&#93;
                best_tag_id &#61; argmax&#40;next_tag_var&#41;
                bptrs_t.append&#40;best_tag_id&#41;
                viterbivars_t.append&#40;next_tag_var&#91;0&#93;&#91;best_tag_id&#93;.view&#40;1&#41;&#41;
            # Now add in the emission scores, and assign forward_var to the set
            # of viterbi variables we just computed
            forward_var &#61; &#40;torch.cat&#40;viterbivars_t&#41; &#43; feat&#41;.view&#40;1, -1&#41;
            backpointers.append&#40;bptrs_t&#41;

        # Transition to STOP_TAG
        terminal_var &#61; forward_var &#43; self.transitions&#91;self.tag_to_ix&#91;STOP_TAG&#93;&#93;
        best_tag_id &#61; argmax&#40;terminal_var&#41;
        path_score &#61; terminal_var&#91;0&#93;&#91;best_tag_id&#93;

        # Follow the back pointers to decode the best path.
        best_path &#61; &#91;best_tag_id&#93;
        for bptrs_t in reversed&#40;backpointers&#41;:
            best_tag_id &#61; bptrs_t&#91;best_tag_id&#93;
            best_path.append&#40;best_tag_id&#41;
        # Pop off the start tag &#40;we dont want to return that to the caller&#41;
        start &#61; best_path.pop&#40;&#41;
        assert start &#61;&#61; self.tag_to_ix&#91;START_TAG&#93;  # Sanity check
        best_path.reverse&#40;&#41;
        return path_score, best_path

    def neg_log_likelihood&#40;self, sentence, tags&#41;:
        feats &#61; self._get_lstm_features&#40;sentence&#41;
        forward_score &#61; self._forward_alg&#40;feats&#41;
        gold_score &#61; self._score_sentence&#40;feats, tags&#41;
        return forward_score - gold_score

    def forward&#40;self, sentence&#41;:  # dont confuse this with _forward_alg above.
        # Get the emission scores from the BiLSTM
        lstm_feats &#61; self._get_lstm_features&#40;sentence&#41;

        # Find the best path, given the features.
        score, tag_seq &#61; self._viterbi_decode&#40;lstm_feats&#41;
        return score, tag_seq</code></pre>
    <p>run training </p>
    <pre><code class="language-python">START_TAG &#61; &quot;&lt;START&gt;&quot;
STOP_TAG &#61; &quot;&lt;STOP&gt;&quot;
EMBEDDING_DIM &#61; 5
HIDDEN_DIM &#61; 4

# Make up some training data
training_data &#61; &#91;&#40;
    &quot;the wall street journal reported today that apple corporation made money&quot;.split&#40;&#41;,
    &quot;B I I I O O O B I O O&quot;.split&#40;&#41;
&#41;, &#40;
    &quot;georgia tech is a university in georgia&quot;.split&#40;&#41;,
    &quot;B I O O O O B&quot;.split&#40;&#41;
&#41;&#93;

word_to_ix &#61; &#123;&#125;
for sentence, tags in training_data:
    for word in sentence:
        if word not in word_to_ix:
            word_to_ix&#91;word&#93; &#61; len&#40;word_to_ix&#41;

tag_to_ix &#61; &#123;&quot;B&quot;: 0, &quot;I&quot;: 1, &quot;O&quot;: 2, START_TAG: 3, STOP_TAG: 4&#125;

model &#61; BiLSTM_CRF&#40;len&#40;word_to_ix&#41;, tag_to_ix, EMBEDDING_DIM, HIDDEN_DIM&#41;
optimizer &#61; optim.SGD&#40;model.parameters&#40;&#41;, lr&#61;0.01, weight_decay&#61;1e-4&#41;

# Check predictions before training
with torch.no_grad&#40;&#41;:
    precheck_sent &#61; prepare_sequence&#40;training_data&#91;0&#93;&#91;0&#93;, word_to_ix&#41;
    precheck_tags &#61; torch.tensor&#40;&#91;tag_to_ix&#91;t&#93; for t in training_data&#91;0&#93;&#91;1&#93;&#93;, dtype&#61;torch.long&#41;
    print&#40;model&#40;precheck_sent&#41;&#41;

# Make sure prepare_sequence from earlier in the LSTM section is loaded
for epoch in range&#40;
        300&#41;:  # again, normally you would NOT do 300 epochs, it is toy data
    for sentence, tags in training_data:
        # Step 1. Remember that Pytorch accumulates gradients.
        # We need to clear them out before each instance
        model.zero_grad&#40;&#41;

        # Step 2. Get our inputs ready for the network, that is,
        # turn them into Tensors of word indices.
        sentence_in &#61; prepare_sequence&#40;sentence, word_to_ix&#41;
        targets &#61; torch.tensor&#40;&#91;tag_to_ix&#91;t&#93; for t in tags&#93;, dtype&#61;torch.long&#41;

        # Step 3. Run our forward pass.
        loss &#61; model.neg_log_likelihood&#40;sentence_in, targets&#41;

        # Step 4. Compute the loss, gradients, and update the parameters by
        # calling optimizer.step&#40;&#41;
        loss.backward&#40;&#41;
        optimizer.step&#40;&#41;

# Check predictions after training
with torch.no_grad&#40;&#41;:
    precheck_sent &#61; prepare_sequence&#40;training_data&#91;0&#93;&#91;0&#93;, word_to_ix&#41;
    print&#40;model&#40;precheck_sent&#41;&#41;
# We got it&#33;</code></pre>
    <div class="page-foot">
      <div class="copyright">
        <a href="https://github.com/shiyis/nlpwsys/tree/master"><b> This page is hosted on <img class="github-logo"
              src="https://unpkg.com/ionicons@5.1.2/dist/svg/logo-github.svg"></img></b></a></br>
        ©️ Last modified: March 13, 2024. Website built with <a
          href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia
          programming language</a>.
      </div>
    </div>
  </div><!-- CONTENT ENDS HERE -->

  <script src="/libs/katex/katex.min.js"></script>
  <script src="/libs/katex/contrib/auto-render.min.js"></script>
  <script>
    renderMathInElement(document.body)

  </script>



  <script src="/libs/highlight/highlight.min.js"></script>
  <script>
    hljs.highlightAll();
    hljs.configure({
      tabReplace: '    '
    });

  </script>


</body>

</html>
