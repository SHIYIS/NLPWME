<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
   <link rel="stylesheet" href="/libs/katex/katex.min.css">
     
   <link rel="stylesheet" href="/libs/highlight/styles/github.min.css">
   

  <link rel="stylesheet" href="/css/franklin.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,400italic|Source+Code+Pro:400,700" type="text/css">
<link rel="stylesheet" href="/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/celeste.min.css">

<link rel="icon" type="image/png" sizes="200x200" href="/assets/robot.png">
<!-- <link rel="shortcut icon" href="/assets/favicon.ico"> -->
<link rel="icon" type="image/png" sizes="152x152" href="/assets/robot_smaller_152x152.png">
<link rel="icon" type="image/x-icon" sizes="64x64" href="/assets/robot_smaller_64x64.png">
<link rel="icon" type="image/x-icon" sizes="32x32" href="/assets/robot_smaller_32x32.png">
<link rel="icon" type="image/png" sizes="64x64" href="/assets/robot_smaller_64x64.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/robot_smaller_32x32.png">


   <title>NLPwShiyi - Natural Language Processing with Shiyi</title>  
</head>
<body>
  <!-- Latest compiled and minified CSS -->

<nav id="navbar" class="navigation" role="navigation">
  <input id="toggle1" type="checkbox" />
  <label class="hamburger1" for="toggle1">
    <div class="top"></div>
    <div class="meat"></div>
    <div class="bottom"></div>
  </label>

  <nav class="topnav mx-auto" id="myTopnav">
    <div class="dropdown">
      <button class="dropbtn">Comp Ling
        <i class="fa fa-caret-down"></i>
      </button>
      <div class="dropdown-content">
        <!-- <a href="/modules/1a-phil-of-mind">Philosophy of Mind</a> -->
        <a href="/modules/1b-info-theory">Information Theory</a>
        <a href="/modules/1c-noisy-channel-model">The Noisy Channel Model</a>
        <a href="/modules/1d-finite-automata">FSAs and FSTs</a>
        <a href="/modules/1e-mutual-info">Mutual Information</a>
        <a href="/modules/1f-cky-algorithm">CKY Algorithm</a>
        <a href="/modules/1g-viterbi">Viterbi Algorithm</a>
        <a href="/modules/1h-semantics">Logic and Problem Solving</a>
        <!-- <a href="/modules/1i-cryptanalysis">Cryptography</a> -->
      </div>
    </div>
    <div class="dropdown">
      <button class="dropbtn" >DL / NLP
        <i class="fa fa-caret-down"></i>
      </button>
      <div class="dropdown-content">
        <!-- <a href="/modules/2a-mdn-nlp">Modern NLP</a> -->
        <a href="/modules/2b-markov-processes">Markov Processes</a>
        <a href="/modules/2e-jax">Jacobian Matrices Derivation</a>
        <a href="/modules/2d-automatic-differentiation">Automatic Differentiation</a>
        <a href="/modules/2f-loss-functions">Stochastic GD</a>
        <a href="/modules/2c-word2vec">Word2Vec</a>
        <a href="/modules/2g-batchnorm">Batchnorm</a>
        <a href="/modules/2j-perplexity">Perplexity</a>
        <a href="/modules/2h-dropout">Dropout</a>
        <a href="/modules/2i-depth">Depth: Pros and Cons</a>
        <a href="/modules/2k-VAE">Variational Autoencoders</a>
        <a href="/modules/2l-dnns">DNNs(RNNs, CNNs, (Bi)-LSTM)</a>
      </div>
    </div>
    <a href="/" class="active">Intro </a>
    <div class="dropdown">
      <button class="dropbtn" >SOTA
        <i class="fa fa-caret-down"></i>
      </button>
      <div class="dropdown-content">

        <a href="/modules/3a-transformers"> GPT (Generative Pre-trained Transformer) </a>
        <a href="/modules/3b-xlnet"> XLNet (Generalized Autoregressive Pretraining) </a>
        <a href="/modules/3c-roberta"> RoBERTa (Robustly optimized BERT approach) </a>
        <a href="/modules/3d-t5"> T5 (Text-to-Text Transfer Transformer) </a>
        <a href="/modules/3e-clip"> CLIP (Contrastive Language-Image Pre-training) </a>
        
        <!-- <a href="/modules/">TODO: Diffusion Prob Models</a> -->
      </div>
    </div>
    <div class="dropdown">
      <button class="dropbtn" >Hands-on
        <i class="fa fa-caret-down"></i>
      </button>
      <div class="dropdown-content">
        <a href="/modules/4a-mlp-from-scratch">MLP from Scratch</a>
        <a href="/modules/4b-generative-adversarial-networks">GAN Example </a>
        <a href="/modules/4c-vae-mnist">VAE for MNIST</a>
        <a href="/modules/4d-bi-lstm-crf">BI-LSTM-CRF Seq2Seq</a>
        <a href="/modules/4e-c4fe-tbip">Text-based Ideal Points Model</a>
        <!-- <a href="/modules/4f-server-build">WebServer Build Example</a> -->
        <a href="/modules/4g-etl-job">Serverless ETL Example</a>
        <a href="/modules/4h-ocr-data-aug">OCR Text Augmentation</a>
        <a href="/modules/4i-neo4j-gql">Neo4j GQL Example</a>
        <!-- <a href="/modules/4j-amr-parser">AMR Parser Example</a> -->


        

      </div>
    </div>
  </nav>
</nav>
  
  
<!-- Content appended here -->
  <!-- {{if hascode}} {{insert copy_paste.html}} {{end}} --><div class="franklin-content"><h1 id="finite_state_machine_and_automata"><a href="#finite_state_machine_and_automata" class="header-anchor">Finite State Machine and Automata</a></h1>
<p>A finite automaton is the most basic machine capable of pattern recognition &#40;FA&#41;. It is used to describe a Regular Language, just like in <code>/baa&#43;&#33;/</code>.</p>
<p>It is also used to recognize and evaluate Natural Language Expressions. There are five parts, or tuples, to the abstract machine called the finite automata or finite state machine. Its various states and the rules for transitioning between them are contingent upon the input symbol that is utilized.</p>
<p>Depending on the states and the regulations, the input string may be accepted or denied. It is essentially a model of an abstract digital computer that interprets an input string and adjusts its internal state based on the input symbol that is being received at that moment.</p>
<p>The following characteristics of automata in the aforementioned figure are</p>
<hr />
<p><img src="../extras/finite_automata/fig1.png" alt="finite_fig1" /></p>
<hr />
<p>Input Output States of automata State relation Output relation A Finite Automata consists of the following:</p>
<pre><code class="language-julia">Q : Finite set of states.       
Σ : set of Input Symbols.       
q : Initial state.       
F : set of Final States.       
δ : Transition Function.</code></pre>
<p>Formal specification of machine is</p>
<pre><code class="language-julia">&#123; Q, Σ, q, F, δ &#125;</code></pre>
<ol>
<li><p>Deterministic Finite Automata &#40;DFA&#41;:</p>
</li>
</ol>
<pre><code class="language-python">DFA consists of 5 tuples &#123;Q, Σ, q, F, δ&#125;.
Q : set of all states.
Σ : set of input symbols. &#40; Symbols which machine takes as input &#41;
q : Initial state. &#40; Starting state of a machine &#41;
F : set of final state.
δ : Transition Function, defined as δ : Q X Σ --&gt; Q.</code></pre>
<p>In a DFA, the machine only enters one state for a specific input character. For every input symbol, a transition function is defined for each state. Additionally, DFA does not support null &#40;or&#41; moves, meaning that it cannot change its state without an input character.</p>
<pre><code class="language-python">Create a DFA that, for instance, only accepts strings that end in &#39;a&#39;.

    Assumed: Σ &#61; &#123;a,b&#125;, q &#61; &#123;q0&#125;, F&#61;&#123;q1&#125;, Q &#61; &#123;q0, q1&#125;

If you want to create a state transition diagram that is accurate, you should first take into account a language set of all the potential acceptable strings.

    L &#61; &#123;a, a, a, a, a, aa, aaa, aaaa, ba, bba, bbbaa, aba, abba, aaba, abaa&#125;

The list above is just a small portion of all possible acceptable strings; there are many other strings that contain the letters &quot;a&quot; and &quot;b&quot;.</code></pre>
<p>See below figure:     As you can see in the transition function is for any input including null &#40;or ?&#41;, NFA can go to any state number of states. For example, below is an NFA for the above problem.</p>
<table><tr><th align="left">State / Symbol</th><th align="left">a</th><th align="left">b</th></tr><tr><td align="left">\(q_0\)</td><td align="left">\({q_0,q_1}\)</td><td align="left">\(q_0\)</td></tr><tr><td align="left">\(q_1\)</td><td align="left">?</td><td align="left">?</td></tr></table>
<hr />
<p><img src="../extras/finite_automata/fig2.png" alt="finite_fig2" /></p>
<hr />
<p>One important thing to note is, in NFA, if any path for an input string leads to a final state, then the input string is accepted. For example, in the above NFA, there are multiple paths for the input string <code>“00”</code>. Since one of the paths leads to a final state, <code>“00”</code> is accepted by the above NFA.</p>
<p>Since all the tuples in DFA and NFA are the same except for one of the tuples, which is Transition Function &#40;?&#41;</p>
<pre><code class="language-julia">In case of DFA
? : Q X ? --&gt; Q
In case of NFA
? : Q X ? --&gt; &#36;2^Q&#36;</code></pre>
<p>ℹ️ Now if you observe you’ll find out <code>Q X ? –&gt; Q</code> is part of <code>Q X ? –&gt; 2 ^ Q</code>.</p>
<p>On the RHS side, Q is the subset of \(2^Q\) which indicates Q is contained in \(2^Q\) or Q is a part of \(2^Q\), however, the reverse isn’t true. So mathematically, we can conclude that every DFA is NFA but not vice-versa. Yet there is a way to convert an NFA to DFA, so there exists an equivalent DFA for every NFA.</p>
<ul>
<li><p>Both NFA and DFA have the same power and each NFA can be translated into a DFA.</p>
</li>
<li><p>There can be multiple final states in both DFA and NFA.</p>
</li>
<li><p>NFA is more of a theoretical concept.</p>
</li>
<li><p>DFA is used in Lexical Analysis in Compiler.</p>
</li>
<li><p>If the number of states in the NFA is N then, its DFA can have maximum \(2^N\) number of states.</p>
</li>
</ul>
<h1 id="onto_the_discussion_about_determinism"><a href="#onto_the_discussion_about_determinism" class="header-anchor">Onto the Discussion about Determinism</a></h1>
<p>The concept of deterministic versus non-deterministic automata is fundamental in computer science, particularly in the theory of computation and formal language theory. Here are some areas where this concept is applied:</p>
<ol>
<li><p><strong>Finite Automata</strong>: Deterministic Finite Automata &#40;DFA&#41; and Non-deterministic Finite Automata &#40;NFA&#41; are used to recognize regular languages. DFAs have a single unique transition from each state for each input symbol, while NFAs can have multiple transitions for the same input symbol from a single state.</p>
</li>
<li><p><strong>Regular Expressions</strong>: Regular expressions are often used to describe patterns in strings. There are algorithms to convert between regular expressions and NFAs, and between NFAs and DFAs.</p>
</li>
<li><p><strong>Compiler Design</strong>: Lexical analysis, which is the first phase of compilation, often involves converting regular expressions describing the language&#39;s tokens into NFAs or DFAs for efficient processing.</p>
</li>
<li><p><strong>Network Protocol Specification</strong>: Automata theory is used to model and verify network protocols. Deterministic and non-deterministic finite automata are used to represent the behavior of the protocols.</p>
</li>
<li><p><strong>Model Checking</strong>: Model checking is a technique used to verify whether a system meets a given specification. Automata are used to model the system&#39;s behavior, and determining whether it&#39;s deterministic or non-deterministic can affect the complexity of the verification process.</p>
</li>
<li><p><strong>Software Verification</strong>: Automata are used in software verification techniques such as symbolic execution and abstract interpretation to analyze and verify the behavior of software systems.</p>
</li>
<li><p><strong>Natural Language Processing</strong>: Automata theory can be applied to tasks like tokenization and morphological analysis in natural language processing.</p>
</li>
<li><p><strong>Database Query Optimization</strong>: Finite automata are used in database query optimization, particularly in pattern matching and indexing.</p>
</li>
</ol>
<p>These are just a few examples of where the concepts of deterministic versus non-deterministic automata find applications. They form a foundational part of theoretical computer science and are applied in various fields where formal language and computational models are relevant.</p>
<h1 id="what_does_being_a_deterministic_vs_non-deterministic_machine_entail"><a href="#what_does_being_a_deterministic_vs_non-deterministic_machine_entail" class="header-anchor">What Does Being A Deterministic vs Non-deterministic Machine Entail?</a></h1>
<p>In the context of automata theory and computational theory, &quot;deterministic&quot; and &quot;non-deterministic&quot; refer to two different types of machines: deterministic machines and non-deterministic machines. These terms describe how these machines make decisions and transitions between states.</p>
<ol>
<li><p><strong>Deterministic</strong>: A deterministic machine is one where, given a particular state and input symbol, there is only one possible next state. In other words, the behavior of the machine is entirely determined by its current state and the input it receives. There are no ambiguities or choices in the transitions between states. Deterministic Finite Automata &#40;DFA&#41; are examples of deterministic machines.</p>
</li>
<li><p><strong>Non-deterministic</strong>: A non-deterministic machine is one where, given a particular state and input symbol, there can be multiple possible next states. This means that the machine can &quot;guess&quot; which state to transition to based on the current state and input. Non-deterministic Finite Automata &#40;NFA&#41; are examples of non-deterministic machines.</p>
</li>
</ol>
<p>Here are some key differences between deterministic and non-deterministic machines:</p>
<ul>
<li><p><strong>Transitions</strong>: Deterministic machines have exactly one possible transition for each state and input symbol pair, while non-deterministic machines may have multiple possible transitions.</p>
</li>
<li><p><strong>Decision Making</strong>: Deterministic machines make decisions based solely on their current state and the input symbol they receive, whereas non-deterministic machines can make &quot;guesses&quot; about which state to transition to.</p>
</li>
<li><p><strong>Ambiguity</strong>: Deterministic machines have no ambiguity in their transitions, whereas non-deterministic machines may have ambiguity due to multiple possible transitions.</p>
</li>
</ul>
<p>In summary, deterministic machines follow a single, predictable path of execution based on their current state and input, while non-deterministic machines have the ability to explore multiple paths simultaneously or make non-deterministic choices during computation.</p>
<div class="page-foot">
    <div class="copyright">
      <a href="https://github.com/shiyis/nlpwsys/tree/master"><b> This page is hosted on <img class="github-logo" src="https://unpkg.com/ionicons@5.1.2/dist/svg/logo-github.svg"></img></b></a></br>
       ©️ Last modified: May 09, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
    </div>
  </div>
  </div><!-- CONTENT ENDS HERE -->
    
        <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/contrib/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>

    
  </body>
</html>
